<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolfenstein 3D Canvas Sprite Animation</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: 'Inter', sans-serif;
            color: #ecf0f1;
        }
        #gameCanvas {
            border: 4px solid #f39c12;
            background-color: #34495e;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            image-rendering: pixelated; /* Crucial for sharp pixel art */
            /* Removed max-width constraints to prevent CSS scaling artifacts */
        }
        h1 {
            color: #f1c40f;
            margin-bottom: 20px;
        }
        .info {
            margin-top: 15px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>B.J. Blazkowicz - Animacja Sprite (Canvas)</h1>
    <canvas id="gameCanvas" width="512" height="512"></canvas>
    <p class="info">Animacja odtwarzana z prędkością 10 klatek na sekundę.</p>

    <script>
        // --- CONFIGURATION ---
        const IMAGE_URL = './blazkowicz.png';
        const COLS = 4;
        const ROWS = 2;
        const TOTAL_FRAMES = COLS * ROWS;
        const FPS = 10;
        const FRAME_DURATION = 1000 / FPS;
        const SCALE = 8; // Global scale multiplier for visible size

        // --- BACKGROUND COLOR TO REMOVE (R:99, G:116, B:125 for #63747d) ---
        const TARGET_BG_R = 99;
        const TARGET_BG_G = 116;
        const TARGET_BG_B = 125;
        // -------------------------------------------------------------------

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let spriteImage = null;
        let frameWidth = 0;
        let frameHeight = 0;
        let currentFrame = 0;
        let lastFrameTime = 0;
        let isReady = false;

        /**
         * 1. Loads the original sprite image.
         * 2. Creates a temporary canvas to detect and remove the background color
         * by setting the alpha channel to 0 for matching pixels.
         * @returns {Promise<HTMLImageElement>} The processed image with transparency.
         */
        function processSpriteSheet() {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous"; // Necessary for cross-origin images
                img.src = IMAGE_URL;

                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;

                    tempCtx.drawImage(img, 0, 0);

                    const imgData = tempCtx.getImageData(0, 0, img.width, img.height);
                    const data = imgData.data;

                    // Now using the exact specified color: #63747d
                    // const bgR = data[0]; // Removed dynamic detection
                    // const bgG = data[1];
                    // const bgB = data[2];

                    // Tolerance increased slightly again to 25 to ensure all pixels near the target color are removed
                    const tolerance = 10; 

                    // Iterate over all pixels (4 components: R, G, B, A)
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];

                        // Check if pixel color is close to the hardcoded background color
                        if (
                            Math.abs(r - TARGET_BG_R) <= tolerance &&
                            Math.abs(g - TARGET_BG_G) <= tolerance &&
                            Math.abs(b - TARGET_BG_B) <= tolerance
                        ) {
                            data[i + 3] = 0; // Set Alpha (A) to 0 (transparent)
                        }
                    }

                    // Put the modified image data back onto the temporary canvas
                    tempCtx.putImageData(imgData, 0, 0);

                    // Create a new Image object from the processed canvas data URL
                    const transparentImg = new Image();
                    transparentImg.onload = () => resolve(transparentImg);
                    transparentImg.onerror = reject;
                    transparentImg.src = tempCanvas.toDataURL(); 
                };
                
                img.onerror = reject;
            });
        }

        /**
         * Main game loop responsible for drawing and animation updates.
         * @param {number} time - High resolution time stamp provided by requestAnimationFrame.
         */
        function gameLoop(time) {
            requestAnimationFrame(gameLoop);

            if (!isReady) return;

            // Update animation frame
            if (time - lastFrameTime >= FRAME_DURATION) {
                currentFrame = (currentFrame + 1) % TOTAL_FRAMES;
                lastFrameTime = time;
                
                // --- DRAWING ---
                
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Calculate source position on the sprite sheet
                const col = currentFrame % COLS;
                const row = Math.floor(currentFrame / COLS);

                // Use Math.floor to ensure integer coordinates (prevents jitter)
                const srcX = Math.floor(col * frameWidth);
                const srcY = Math.floor(row * frameHeight);

                // Destination matches the exact canvas size now
                const destW = canvas.width;
                const destH = canvas.height;
                const destX = 0;
                const destY = 0;

                // Draw the current frame from the sprite sheet onto the canvas
                ctx.drawImage(
                    spriteImage, 
                    srcX, srcY, frameWidth, frameHeight, // Source clipping
                    destX, destY, destW, destH          // Destination size and position
                );
            }
        }

        /**
         * Initialization function.
         */
        async function init() {
            try {
                spriteImage = await processSpriteSheet();
                
                // Calculate dimensions for a single frame using Math.floor to avoid sub-pixel rendering issues
                frameWidth = Math.floor(spriteImage.width / COLS);
                frameHeight = Math.floor(spriteImage.height / ROWS);

                console.log(`Frame Size: ${frameWidth}x${frameHeight}`);

                // Set canvas size exactly to the scaled sprite size (removed * 2 multiplier)
                canvas.width = frameWidth * SCALE;
                canvas.height = frameHeight * SCALE;
                
                // Set the canvas context to draw pixelated images cleanly
                ctx.imageSmoothingEnabled = false; 

                isReady = true;
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("Error during initialization:", error);
                ctx.fillStyle = 'red';
                ctx.font = '20px Arial';
                ctx.fillText("Błąd ładowania obrazka. Sprawdź konsolę.", 10, 50);
            }
        }

        // Run the initialization
        init();
    </script>
</body>
</html>